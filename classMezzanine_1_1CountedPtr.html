<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mezzanine::CountedPtr&lt; TypePointedTo &gt; Class Template Reference</title>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="DoxyStyle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script> 
</head>
<body onload='searchBox.OnSelectItem(0);'>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;" nowrap="nowrap">
   <div id="projectname"><a href="http://blacktoppstudios.com"><img src="logogreen100pxtall.png"/></a>MezzanineEngine&#160;<span id="projectnumber">September&nbsp;24,&nbsp;2013</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMezzanine.html">Mezzanine</a></li><li class="navelem"><a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classMezzanine_1_1CountedPtr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mezzanine::CountedPtr&lt; TypePointedTo &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple reference counting pointer.  
 <a href="classMezzanine_1_1CountedPtr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="smartptr_8h_source.html">smartptr.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Mezzanine::CountedPtr&lt; TypePointedTo &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMezzanine_1_1CountedPtr__coll__graph.svg" width="235" height="174"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3bad88b1ac4c311ca63891bc5689582b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bad88b1ac4c311ca63891bc5689582b"></a>
typedef TypePointedTo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a3bad88b1ac4c311ca63891bc5689582b">element_type</a></td></tr>
<tr class="memdesc:a3bad88b1ac4c311ca63891bc5689582b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This makes referencing the type of the pointer object easier for external classes. <br/></td></tr>
<tr class="separator:a3bad88b1ac4c311ca63891bc5689582b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5049e9157bf5a997625b6189da55474b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5049e9157bf5a997625b6189da55474b"></a>
typedef <a class="el" href="classMezzanine_1_1ReferenceCountTraits.html">ReferenceCountTraits</a><br class="typebreak"/>
&lt; TypePointedTo &gt;<br class="typebreak"/>
::<a class="el" href="classMezzanine_1_1CountedPtr.html#a5049e9157bf5a997625b6189da55474b">RefCountType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a5049e9157bf5a997625b6189da55474b">RefCountType</a></td></tr>
<tr class="memdesc:a5049e9157bf5a997625b6189da55474b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The non pointer version of PtrType. <br/></td></tr>
<tr class="separator:a5049e9157bf5a997625b6189da55474b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab53831e2af99d19396cfab5016c640bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#ab53831e2af99d19396cfab5016c640bd">CountedPtr</a> (TypePointedTo *PointerTarget=0)  throw ()</td></tr>
<tr class="memdesc:ab53831e2af99d19396cfab5016c640bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializing Constructor.  <a href="#ab53831e2af99d19396cfab5016c640bd">More...</a><br/></td></tr>
<tr class="separator:ab53831e2af99d19396cfab5016c640bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfa958ec832f805959518cb9eeb8302"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a6cfa958ec832f805959518cb9eeb8302">CountedPtr</a> (const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a> &amp;Original)  throw ()</td></tr>
<tr class="memdesc:a6cfa958ec832f805959518cb9eeb8302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a6cfa958ec832f805959518cb9eeb8302">More...</a><br/></td></tr>
<tr class="separator:a6cfa958ec832f805959518cb9eeb8302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bae524490b6dba55bbe501cb9ff1067"><td class="memTemplParams" colspan="2">template&lt;typename OtherPointer &gt; </td></tr>
<tr class="memitem:a2bae524490b6dba55bbe501cb9ff1067"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a2bae524490b6dba55bbe501cb9ff1067">CountedPtr</a> (const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; OtherPointer &gt; &amp;Original)  throw ()</td></tr>
<tr class="memdesc:a2bae524490b6dba55bbe501cb9ff1067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casting copy constructor.  <a href="#a2bae524490b6dba55bbe501cb9ff1067">More...</a><br/></td></tr>
<tr class="separator:a2bae524490b6dba55bbe501cb9ff1067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9ed87946e558881b33070519764240"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f9ed87946e558881b33070519764240"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a8f9ed87946e558881b33070519764240">~CountedPtr</a> ()  throw ()</td></tr>
<tr class="memdesc:a8f9ed87946e558881b33070519764240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconstructor, Just calls <a class="el" href="classMezzanine_1_1CountedPtr.html#aedb1e5da381fcbf10c7737d4383fb715" title="This decrements the reference count and deletes the managed items if there are no remaining reference...">Release()</a>. <br/></td></tr>
<tr class="separator:a8f9ed87946e558881b33070519764240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0ded0cddc359ddea1f557fe796095e"><td class="memItemLeft" align="right" valign="top">TypePointedTo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#aac0ded0cddc359ddea1f557fe796095e">Get</a> () const   throw ()</td></tr>
<tr class="memdesc:aac0ded0cddc359ddea1f557fe796095e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw pointer to the managed object.  <a href="#aac0ded0cddc359ddea1f557fe796095e">More...</a><br/></td></tr>
<tr class="separator:aac0ded0cddc359ddea1f557fe796095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f00c38226d1ae4f7797fe5944a53333"><td class="memItemLeft" align="right" valign="top">TypePointedTo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a6f00c38226d1ae4f7797fe5944a53333">get</a> () const   throw ()</td></tr>
<tr class="memdesc:a6f00c38226d1ae4f7797fe5944a53333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw pointer to the managed object.  <a href="#a6f00c38226d1ae4f7797fe5944a53333">More...</a><br/></td></tr>
<tr class="separator:a6f00c38226d1ae4f7797fe5944a53333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e56fb6b7fdfca4aa1c2b71e875e9589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1CountedPtr.html#a5049e9157bf5a997625b6189da55474b">RefCountType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a2e56fb6b7fdfca4aa1c2b71e875e9589">GetReferenceCount</a> () const   throw ()</td></tr>
<tr class="memdesc:a2e56fb6b7fdfca4aa1c2b71e875e9589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal Reference count.  <a href="#a2e56fb6b7fdfca4aa1c2b71e875e9589">More...</a><br/></td></tr>
<tr class="separator:a2e56fb6b7fdfca4aa1c2b71e875e9589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51e34d919592035a7829e23a67e66e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#ac51e34d919592035a7829e23a67e66e2">operator bool</a> () const   throw ()</td></tr>
<tr class="memdesc:ac51e34d919592035a7829e23a67e66e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pointer points to something.  <a href="#ac51e34d919592035a7829e23a67e66e2">More...</a><br/></td></tr>
<tr class="separator:ac51e34d919592035a7829e23a67e66e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbe491e40d8adbaa372890501dcc5b1"><td class="memItemLeft" align="right" valign="top">TypePointedTo &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a9fbe491e40d8adbaa372890501dcc5b1">operator*</a> () const   throw ()</td></tr>
<tr class="memdesc:a9fbe491e40d8adbaa372890501dcc5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator.  <a href="#a9fbe491e40d8adbaa372890501dcc5b1">More...</a><br/></td></tr>
<tr class="separator:a9fbe491e40d8adbaa372890501dcc5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d0f8a1a22daa3a06394aa1430a6299"><td class="memItemLeft" align="right" valign="top">TypePointedTo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a88d0f8a1a22daa3a06394aa1430a6299">operator-&gt;</a> () const   throw ()</td></tr>
<tr class="memdesc:a88d0f8a1a22daa3a06394aa1430a6299"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Structure dereference operator.  <a href="#a88d0f8a1a22daa3a06394aa1430a6299">More...</a><br/></td></tr>
<tr class="separator:a88d0f8a1a22daa3a06394aa1430a6299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccd80ffc3d1e940b26dbbec0653e0f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#afccd80ffc3d1e940b26dbbec0653e0f9">operator=</a> (const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a> &amp;Other)  throw ()</td></tr>
<tr class="memdesc:afccd80ffc3d1e940b26dbbec0653e0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignement operator.  <a href="#afccd80ffc3d1e940b26dbbec0653e0f9">More...</a><br/></td></tr>
<tr class="separator:afccd80ffc3d1e940b26dbbec0653e0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568399115faa2872525933a4baf24c67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a568399115faa2872525933a4baf24c67">operator==</a> (const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a> &amp;Other) const   throw ()</td></tr>
<tr class="memdesc:a568399115faa2872525933a4baf24c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comparision of two <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> instances.  <a href="#a568399115faa2872525933a4baf24c67">More...</a><br/></td></tr>
<tr class="separator:a568399115faa2872525933a4baf24c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69254cff8b760916d88f7181c714dba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69254cff8b760916d88f7181c714dba1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a69254cff8b760916d88f7181c714dba1">Reset</a> ()</td></tr>
<tr class="memdesc:a69254cff8b760916d88f7181c714dba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset this to point at nothing. <br/></td></tr>
<tr class="separator:a69254cff8b760916d88f7181c714dba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7183bd295910f8a43b3eff118ff17bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#ab7183bd295910f8a43b3eff118ff17bf">reset</a> ()</td></tr>
<tr class="memdesc:ab7183bd295910f8a43b3eff118ff17bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset this to point at nothing.  <a href="#ab7183bd295910f8a43b3eff118ff17bf">More...</a><br/></td></tr>
<tr class="separator:ab7183bd295910f8a43b3eff118ff17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155b9da33dc7ca0ed48df08f5a46a4a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a155b9da33dc7ca0ed48df08f5a46a4a4">Reset</a> (const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; TypePointedTo &gt; &amp;Other)</td></tr>
<tr class="memdesc:a155b9da33dc7ca0ed48df08f5a46a4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset this to point at the same as another <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> of the same type.  <a href="#a155b9da33dc7ca0ed48df08f5a46a4a4">More...</a><br/></td></tr>
<tr class="separator:a155b9da33dc7ca0ed48df08f5a46a4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966f5b0ede3ea960e9afdf8173b87075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a966f5b0ede3ea960e9afdf8173b87075">reset</a> (const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; TypePointedTo &gt; &amp;Other)</td></tr>
<tr class="memdesc:a966f5b0ede3ea960e9afdf8173b87075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset this to point at the same as another <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> of the same type.  <a href="#a966f5b0ede3ea960e9afdf8173b87075">More...</a><br/></td></tr>
<tr class="separator:a966f5b0ede3ea960e9afdf8173b87075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf18b0278f6b29540d22f809ebe39bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a3bf18b0278f6b29540d22f809ebe39bf">Reset</a> (TypePointedTo *PointerTarget)</td></tr>
<tr class="memdesc:a3bf18b0278f6b29540d22f809ebe39bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of the passed pointer.  <a href="#a3bf18b0278f6b29540d22f809ebe39bf">More...</a><br/></td></tr>
<tr class="separator:a3bf18b0278f6b29540d22f809ebe39bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ace3eb0eec9ffa2fdcef2df29cd14d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#aa2ace3eb0eec9ffa2fdcef2df29cd14d">reset</a> (TypePointedTo *PointerTarget)</td></tr>
<tr class="memdesc:aa2ace3eb0eec9ffa2fdcef2df29cd14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of the passed pointer.  <a href="#aa2ace3eb0eec9ffa2fdcef2df29cd14d">More...</a><br/></td></tr>
<tr class="separator:aa2ace3eb0eec9ffa2fdcef2df29cd14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade173bb7d89add8eaed344b358eadf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#aade173bb7d89add8eaed344b358eadf4">Unique</a> () const   throw ()</td></tr>
<tr class="memdesc:aade173bb7d89add8eaed344b358eadf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this the only pointer to the managed object.  <a href="#aade173bb7d89add8eaed344b358eadf4">More...</a><br/></td></tr>
<tr class="separator:aade173bb7d89add8eaed344b358eadf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae991b2beca4077dc40c53110bc97308c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#ae991b2beca4077dc40c53110bc97308c">unique</a> () const   throw ()</td></tr>
<tr class="memdesc:ae991b2beca4077dc40c53110bc97308c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this the only pointer to the managed object.  <a href="#ae991b2beca4077dc40c53110bc97308c">More...</a><br/></td></tr>
<tr class="separator:ae991b2beca4077dc40c53110bc97308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a59d2a510912444ba6123585b4b01d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMezzanine.html#adcbb6ce6d1eb4379d109e51171e2e493">Whole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#af7a59d2a510912444ba6123585b4b01d">use_count</a> () const   throw ()</td></tr>
<tr class="memdesc:af7a59d2a510912444ba6123585b4b01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current count of references.  <a href="#af7a59d2a510912444ba6123585b4b01d">More...</a><br/></td></tr>
<tr class="separator:af7a59d2a510912444ba6123585b4b01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe44fb8d85954d63e3d06e7a88611a11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMezzanine.html#adcbb6ce6d1eb4379d109e51171e2e493">Whole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#abe44fb8d85954d63e3d06e7a88611a11">UseCount</a> () const   throw ()</td></tr>
<tr class="memdesc:abe44fb8d85954d63e3d06e7a88611a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current count of references.  <a href="#abe44fb8d85954d63e3d06e7a88611a11">More...</a><br/></td></tr>
<tr class="separator:abe44fb8d85954d63e3d06e7a88611a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8928e944ee2b9f069421242ed0d3f0da"><td class="memTemplParams" colspan="2">template&lt;typename AnyReferenceCountType &gt; </td></tr>
<tr class="memitem:a8928e944ee2b9f069421242ed0d3f0da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a8928e944ee2b9f069421242ed0d3f0da">Acquire</a> (AnyReferenceCountType *CounterToAcquire)  throw ()</td></tr>
<tr class="memdesc:a8928e944ee2b9f069421242ed0d3f0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Have this pointer point at the same thing another pointer points to,.  <a href="#a8928e944ee2b9f069421242ed0d3f0da">More...</a><br/></td></tr>
<tr class="separator:a8928e944ee2b9f069421242ed0d3f0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cce00e9d7683271d77e8ede266b068e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a3cce00e9d7683271d77e8ede266b068e">FirstAcquire</a> (TypePointedTo *PointerTarget)</td></tr>
<tr class="memdesc:a3cce00e9d7683271d77e8ede266b068e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If required create a reference counter and point this at the passed pointer.  <a href="#a3cce00e9d7683271d77e8ede266b068e">More...</a><br/></td></tr>
<tr class="separator:a3cce00e9d7683271d77e8ede266b068e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb1e5da381fcbf10c7737d4383fb715"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedb1e5da381fcbf10c7737d4383fb715"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#aedb1e5da381fcbf10c7737d4383fb715">Release</a> ()  throw ()</td></tr>
<tr class="memdesc:aedb1e5da381fcbf10c7737d4383fb715"><td class="mdescLeft">&#160;</td><td class="mdescRight">This decrements the reference count and deletes the managed items if there are no remaining references. <br/></td></tr>
<tr class="separator:aedb1e5da381fcbf10c7737d4383fb715"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4228191231e5973125972a17047b02c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4228191231e5973125972a17047b02c7"></a>
<a class="el" href="classMezzanine_1_1CountedPtr.html#a5049e9157bf5a997625b6189da55474b">RefCountType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#a4228191231e5973125972a17047b02c7">_ReferenceCounter</a></td></tr>
<tr class="memdesc:a4228191231e5973125972a17047b02c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the only data on this class, a pointer to the counter and the managed object. <br/></td></tr>
<tr class="separator:a4228191231e5973125972a17047b02c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae7db19162dcfa97421b8b546221a8fa0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7db19162dcfa97421b8b546221a8fa0"></a>
template&lt;typename OtherPointer &gt; </td></tr>
<tr class="memitem:ae7db19162dcfa97421b8b546221a8fa0"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#ae7db19162dcfa97421b8b546221a8fa0">CountedPtr</a></td></tr>
<tr class="memdesc:ae7db19162dcfa97421b8b546221a8fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">declare all pointers as friends so they can reference eachother _ReferenceCounter. <br/></td></tr>
<tr class="separator:ae7db19162dcfa97421b8b546221a8fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e76047ecb1b7b19bd7745475e82cce"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename OtherPointerTargetType &gt; </td></tr>
<tr class="memitem:aa5e76047ecb1b7b19bd7745475e82cce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; ReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1CountedPtr.html#aa5e76047ecb1b7b19bd7745475e82cce">CountedPtrStaticCast</a> (<a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; OtherPointerTargetType &gt; &amp;Original)</td></tr>
<tr class="memdesc:aa5e76047ecb1b7b19bd7745475e82cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static casting can access internals also.  <a href="#aa5e76047ecb1b7b19bd7745475e82cce">More...</a><br/></td></tr>
<tr class="separator:aa5e76047ecb1b7b19bd7745475e82cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TypePointedTo&gt;<br/>
class Mezzanine::CountedPtr&lt; TypePointedTo &gt;</h3>

<p>A simple reference counting pointer. </p>
<p>This is a pointer that automatically deallocates the object it manages when all <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> intances managing it are destroyed or fall out of scope. This is a simpler version of std::shared_ptr. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is not thread safe by default. </dd>
<dd>
If you intead to have covariant pointers (Multiple pointers to the same item but with different type date, like more base or more derived pointers) all classes pointed to must have virtual deconstructors </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The basis of this class originated externally, please see the counted pointer from <a href="http://ootips.org/yonat/4dev/smart-pointers.html">http://ootips.org/yonat/4dev/smart-pointers.html</a> which came with written permission for use stated as "Feel free to use my own smart pointers in your code" on that page. </dd></dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00071">71</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab53831e2af99d19396cfab5016c640bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::<a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">TypePointedTo *&#160;</td>
          <td class="paramname"><em>PointerTarget</em> = <code>0</code></td><td>)</td>
          <td>  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializing Constructor. </p>
<p>This should only be used for initial creation of a shared pointer group. This will allocate the raw pointer and the ReferenceCounter that will be used to track the pointer passed. This will only be explicitly called to prevent accidental premature deletion of the item managed. <br/>
 <br/>
 It is quite easy to accidentally make a secondary group of counted pointers if not using the new statement inline with this constructor, and it is not recomended to use this in any other way. Here is an example of the recommended way to use new inline with this: "Mezzanine::CountedPtr&lt;Mezzanine::Vector3&gt; VecPtr (new Mezzanine::Vector3);" </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PointerTarget</td><td>The item that will be deleted once all the pointer of this group disappear. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00346">346</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6cfa958ec832f805959518cb9eeb8302"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::<a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; TypePointedTo &gt; &amp;&#160;</td>
          <td class="paramname"><em>Original</em></td><td>)</td>
          <td>  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Original</td><td>The pointer being copied. This fresh pointer will use the same ReferenceCounter as the original. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does throws exceptions. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00361">361</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2bae524490b6dba55bbe501cb9ff1067"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<div class="memtemplate">
template&lt;typename OtherPointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::<a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; OtherPointer &gt; &amp;&#160;</td>
          <td class="paramname"><em>Original</em></td><td>)</td>
          <td>  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casting copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Original</td><td>The <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> being copied. This fresh pointer will use the same ReferenceCounter as the original. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does throws exceptions, unless the casting mechanism throws, which it shouldn't. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00368">368</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8928e944ee2b9f069421242ed0d3f0da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<div class="memtemplate">
template&lt;typename AnyReferenceCountType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::Acquire </td>
          <td>(</td>
          <td class="paramtype">AnyReferenceCountType *&#160;</td>
          <td class="paramname"><em>CounterToAcquire</em></td><td>)</td>
          <td>  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Have this pointer point at the same thing another pointer points to,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CounterToAcquire</td><td>The ReferenceCounter that this pointer will use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This does not Release the previous Reference counter. This means it is possible leak memory if a ReferenceCounter is acquired that differs from the previous one without plans to manage the original. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does not throw exceptions, unless debug logging is enabled, then it can throw any exception the logger can throw. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00311">311</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3cce00e9d7683271d77e8ede266b068e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::FirstAcquire </td>
          <td>(</td>
          <td class="paramtype">TypePointedTo *&#160;</td>
          <td class="paramname"><em>PointerTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If required create a reference counter and point this at the passed pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PointerTarget</td><td>the Pointer to take ownership of. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00333">333</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac0ded0cddc359ddea1f557fe796095e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TypePointedTo* <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::Get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raw pointer to the managed object. </p>
<dl class="section return"><dt>Returns</dt><dd>The raw pointer to the managed object or 0 if this pointer is invalid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does not throw exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This name was chosen to match standard compliant names, and should be usable in templates that require this function. </dd></dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00458">458</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6f00c38226d1ae4f7797fe5944a53333"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TypePointedTo* <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raw pointer to the managed object. </p>
<dl class="section return"><dt>Returns</dt><dd>The raw pointer to the managed object or 0 if this pointer is invalid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does not throw exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This name was chosen to match standard compliant names, and should be usable in templates that require this function. </dd></dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00463">463</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2e56fb6b7fdfca4aa1c2b71e875e9589"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1CountedPtr.html#a5049e9157bf5a997625b6189da55474b">RefCountType</a>* <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::GetReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the internal Reference count. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to internal reference count of this pointer. </dd></dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00494">494</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac51e34d919592035a7829e23a67e66e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pointer points to something. </p>
<dl class="section warning"><dt>Warning</dt><dd>Without C++11 this can be accidentally easily be cast to a bool and can do sill things. </dd></dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00488">488</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9fbe491e40d8adbaa372890501dcc5b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TypePointedTo&amp; <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference operator. </p>
<dl class="section return"><dt>Returns</dt><dd>The managed object is returned by reference. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does not throw exceptions. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00445">445</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a88d0f8a1a22daa3a06394aa1430a6299"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TypePointedTo* <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Structure dereference operator. </p>
<dl class="section return"><dt>Returns</dt><dd>Makes it appear, syntactically, as though you are dereferencing the raw pointer. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does not throw exceptions. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00451">451</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="afccd80ffc3d1e940b26dbbec0653e0f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&amp; <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; TypePointedTo &gt; &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td>  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignement operator. </p>
<p>This safely handles the semantics or release the previously assigned object and acquiring the new managed object. This performs basic checks as expected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Other</td><td>The Item on the right hand side of the '=', which this class instance will copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this. </dd></dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00433">433</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a568399115faa2872525933a4baf24c67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; TypePointedTo &gt; &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A comparision of two <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> instances. </p>
<p>This is used to see if this and another <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> are managing the same object and are part of the same group of <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> managing that object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Other</td><td>The <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> on the right hand side of the == </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns true if this and Other use the same reference count and pointer. </dd></dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00483">483</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7183bd295910f8a43b3eff118ff17bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset this to point at nothing. </p>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00383">383</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a155b9da33dc7ca0ed48df08f5a46a4a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::Reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; TypePointedTo &gt; &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset this to point at the same as another <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Other</td><td>Another <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> which will share ownership of the target. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00388">388</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a966f5b0ede3ea960e9afdf8173b87075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; TypePointedTo &gt; &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset this to point at the same as another <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Other</td><td>Another <a class="el" href="classMezzanine_1_1CountedPtr.html" title="A simple reference counting pointer.">CountedPtr</a> which will share ownership of the target. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00398">398</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3bf18b0278f6b29540d22f809ebe39bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::Reset </td>
          <td>(</td>
          <td class="paramtype">TypePointedTo *&#160;</td>
          <td class="paramname"><em>PointerTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take ownership of the passed pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PointerTarget</td><td>The pointer to assume ownership of. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00403">403</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa2ace3eb0eec9ffa2fdcef2df29cd14d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">TypePointedTo *&#160;</td>
          <td class="paramname"><em>PointerTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take ownership of the passed pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PointerTarget</td><td>The pointer to assume ownership of. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00413">413</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="aade173bb7d89add8eaed344b358eadf4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::Unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this the only pointer to the managed object. </p>
<dl class="section return"><dt>Returns</dt><dd>True if <a class="el" href="classMezzanine_1_1CountedPtr.html#af7a59d2a510912444ba6123585b4b01d" title="Get the current count of references. ">use_count()</a> == 1 or if the pointer is invalid </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does not throw exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This name was chosen to match standard compliant names, and should be usable in templates that require this function. </dd></dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00470">470</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae991b2beca4077dc40c53110bc97308c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this the only pointer to the managed object. </p>
<dl class="section return"><dt>Returns</dt><dd>True if <a class="el" href="classMezzanine_1_1CountedPtr.html#af7a59d2a510912444ba6123585b4b01d" title="Get the current count of references. ">use_count()</a> == 1 or if the pointer is invalid </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does not throw exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This name was chosen to match standard compliant names, and should be usable in templates that require this function. </dd></dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00475">475</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="af7a59d2a510912444ba6123585b4b01d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMezzanine.html#adcbb6ce6d1eb4379d109e51171e2e493">Whole</a> <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current count of references. </p>
<dl class="section note"><dt>Note</dt><dd>This name was chosen to match standard compliant names, and should be usable in templates that require this function. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of references which still exist, or 0 if the reference counter is somehow invalid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does not throws exceptions. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00425">425</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="abe44fb8d85954d63e3d06e7a88611a11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMezzanine.html#adcbb6ce6d1eb4379d109e51171e2e493">Whole</a> <a class="el" href="classMezzanine_1_1CountedPtr.html">Mezzanine::CountedPtr</a>&lt; TypePointedTo &gt;::UseCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current count of references. </p>
<dl class="section note"><dt>Note</dt><dd>This name was chosen to match standard compliant names, and should be usable in templates that require this function. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of references which still exist, or 0 if the reference counter is somehow invalid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing</td><td>This member function does not throws exceptions. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="smartptr_8h_source.html#l00420">420</a> of file <a class="el" href="smartptr_8h_source.html">smartptr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aa5e76047ecb1b7b19bd7745475e82cce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypePointedTo&gt; </div>
<div class="memtemplate">
template&lt;typename ReturnType , typename OtherPointerTargetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt;ReturnType&gt; CountedPtrStaticCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1CountedPtr.html">CountedPtr</a>&lt; OtherPointerTargetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>Original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static casting can access internals also. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ReturnType</td><td>The type to be returned, must be specified </td></tr>
    <tr><td class="paramname">OtherPointerTargetType</td><td>The type of the provided pointer, this can be infered and should not be provided. </td></tr>
    <tr><td class="paramname">Original</td><td>The pointer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either a pointer of the desired or a compilation error </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/Code/Mezzanine/Mezzanine/src/<a class="el" href="smartptr_8h_source.html">smartptr.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 24 2013 00:48:42 for MezzanineEngine by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1</small></address>
</body>
</html>
