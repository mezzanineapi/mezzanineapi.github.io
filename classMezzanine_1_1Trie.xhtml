<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mezzanine::Trie&lt; T, V, Cmp, Items &gt; Class Template Reference</title>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="DoxyStyle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script> 
</head>
<body onload='searchBox.OnSelectItem(0);'>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;" nowrap="nowrap">
   <div id="projectname"><a href="http://blacktoppstudios.com"><img src="logogreen100pxtall.png"/></a>MezzanineEngine&#160;<span id="projectnumber">September 2, 2013</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.xhtml"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.xhtml"><span>Class&#160;List</span></a></li>
      <li><a href="classes.xhtml"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.xhtml"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.xhtml"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMezzanine.xhtml">Mezzanine</a></li><li class="navelem"><a class="el" href="classMezzanine_1_1Trie.xhtml">Trie</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMezzanine_1_1Trie-members.xhtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mezzanine::Trie&lt; T, V, Cmp, Items &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> main class.  
 <a href="classMezzanine_1_1Trie.xhtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="trie_8h_source.xhtml">trie.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a75634ce92cce16b02faacbdf44577f4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75634ce92cce16b02faacbdf44577f4e"></a>
typedef <a class="el" href="classMezzanine_1_1Node.xhtml">Node</a>&lt; T, V, Cmp, Items &gt;<br class="typebreak"/>
::<a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a75634ce92cce16b02faacbdf44577f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d590c181ec3477b45156907e7ed6e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19d590c181ec3477b45156907e7ed6e7"></a>
typedef <a class="el" href="classMezzanine_1_1Node.xhtml">Node</a>&lt; T, V, Cmp, Items &gt;<br class="typebreak"/>
::<a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a19d590c181ec3477b45156907e7ed6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad7376e936e82653cbab401ed7d687491"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#ad7376e936e82653cbab401ed7d687491">Trie</a> (const T &amp;<a class="el" href="classMezzanine_1_1Trie.xhtml#acdbcd1af4164693fd620555c54fa4e14">endSymbol</a>)</td></tr>
<tr class="separator:ad7376e936e82653cbab401ed7d687491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd0c3d9f2dba87694ccc8d8bbc8d11e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a4dd0c3d9f2dba87694ccc8d8bbc8d11e">begin</a> ()</td></tr>
<tr class="separator:a4dd0c3d9f2dba87694ccc8d8bbc8d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc492cd9669d95794902f950e4fc4de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#afc492cd9669d95794902f950e4fc4de9">begin</a> () const </td></tr>
<tr class="separator:afc492cd9669d95794902f950e4fc4de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262a7d3ac86df54b33e288a66f4b52a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a262a7d3ac86df54b33e288a66f4b52a4">clear</a> ()</td></tr>
<tr class="separator:a262a7d3ac86df54b33e288a66f4b52a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4998ab08d9805d20d80db053bf697829"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a4998ab08d9805d20d80db053bf697829">empty</a> () const </td></tr>
<tr class="separator:a4998ab08d9805d20d80db053bf697829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e820b5697ad8730d9dd55e99a717a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a18e820b5697ad8730d9dd55e99a717a6">end</a> ()</td></tr>
<tr class="separator:a18e820b5697ad8730d9dd55e99a717a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66193cb5ac0e09be52920001be7756f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a66193cb5ac0e09be52920001be7756f4">end</a> () const </td></tr>
<tr class="separator:a66193cb5ac0e09be52920001be7756f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbcd1af4164693fd620555c54fa4e14"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#acdbcd1af4164693fd620555c54fa4e14">endSymbol</a> () const </td></tr>
<tr class="separator:acdbcd1af4164693fd620555c54fa4e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c1f0d6190a5f9d697c2bbe7d3b7f66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a75c1f0d6190a5f9d697c2bbe7d3b7f66">erase</a> (const T *key)</td></tr>
<tr class="separator:a75c1f0d6190a5f9d697c2bbe7d3b7f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4619367a402a232f481b1d641086c55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#ac4619367a402a232f481b1d641086c55">erase</a> (const std::vector&lt; T &gt; &amp;key)</td></tr>
<tr class="separator:ac4619367a402a232f481b1d641086c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab950dee1f5c6f8febdaac8680d67f7ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#ab950dee1f5c6f8febdaac8680d67f7ce">erase</a> (<a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a> pos)</td></tr>
<tr class="separator:ab950dee1f5c6f8febdaac8680d67f7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd96c9934412acf143d02a04611402e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#acbd96c9934412acf143d02a04611402e">find</a> (const T *key)</td></tr>
<tr class="separator:acbd96c9934412acf143d02a04611402e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62d2af1cdba67c2548559dfbc3eb3d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#af62d2af1cdba67c2548559dfbc3eb3d3">find</a> (const std::vector&lt; T &gt; &amp;key)</td></tr>
<tr class="separator:af62d2af1cdba67c2548559dfbc3eb3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfc6490c6fb9c97e9eb2f9398a8f2b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a2cfc6490c6fb9c97e9eb2f9398a8f2b6">find</a> (const T *key) const </td></tr>
<tr class="separator:a2cfc6490c6fb9c97e9eb2f9398a8f2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d22651cec97e81fbbb72afa11ada20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a33d22651cec97e81fbbb72afa11ada20">find</a> (const std::vector&lt; T &gt; &amp;key) const </td></tr>
<tr class="separator:a33d22651cec97e81fbbb72afa11ada20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f6a2995c275b9f6af235449eae0164"><td class="memItemLeft" align="right" valign="top">const V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a01f6a2995c275b9f6af235449eae0164">get</a> (const T *key) const </td></tr>
<tr class="separator:a01f6a2995c275b9f6af235449eae0164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38579433efd18197dc1ecd561e7f980e"><td class="memItemLeft" align="right" valign="top">const V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a38579433efd18197dc1ecd561e7f980e">get</a> (const std::vector&lt; T &gt; &amp;key) const </td></tr>
<tr class="separator:a38579433efd18197dc1ecd561e7f980e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31de0baad77dd4b4e3dcf6ec5b6acf83"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a31de0baad77dd4b4e3dcf6ec5b6acf83">get</a> (const T *key)</td></tr>
<tr class="separator:a31de0baad77dd4b4e3dcf6ec5b6acf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcbfec88414be1df315332eca91f37e"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#aafcbfec88414be1df315332eca91f37e">get</a> (const std::vector&lt; T &gt; &amp;key)</td></tr>
<tr class="separator:aafcbfec88414be1df315332eca91f37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9ae81ddaee9806e4a9570e6a668a65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a3f9ae81ddaee9806e4a9570e6a668a65">hasKey</a> (const T *key) const </td></tr>
<tr class="separator:a3f9ae81ddaee9806e4a9570e6a668a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8eac01bdeb5aeab9db1cf5b31a72c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a9a8eac01bdeb5aeab9db1cf5b31a72c1">hasKey</a> (const std::vector&lt; T &gt; &amp;key) const </td></tr>
<tr class="separator:a9a8eac01bdeb5aeab9db1cf5b31a72c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67580e4e58c4f7c792cfc9cb6c310adc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a67580e4e58c4f7c792cfc9cb6c310adc">insert</a> (const T *key, V const &amp;value)</td></tr>
<tr class="separator:a67580e4e58c4f7c792cfc9cb6c310adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac026d0ba7f978e5c5255c31fd7dd5c2f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#ac026d0ba7f978e5c5255c31fd7dd5c2f">insert</a> (const std::vector&lt; T &gt; &amp;key, V const &amp;value)</td></tr>
<tr class="separator:ac026d0ba7f978e5c5255c31fd7dd5c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4908e8278627fe1bd16d388ecfd86b"><td class="memItemLeft" align="right" valign="top">V &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#aab4908e8278627fe1bd16d388ecfd86b">operator[]</a> (const T *key)</td></tr>
<tr class="separator:aab4908e8278627fe1bd16d388ecfd86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4404d2030747b2306e9c4d5ed8c2ee58"><td class="memItemLeft" align="right" valign="top">V &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a4404d2030747b2306e9c4d5ed8c2ee58">operator[]</a> (const std::vector&lt; T &gt; &amp;key)</td></tr>
<tr class="separator:a4404d2030747b2306e9c4d5ed8c2ee58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899670b9ec280f0a8b03d8f223e508e1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a899670b9ec280f0a8b03d8f223e508e1">size</a> () const </td></tr>
<tr class="separator:a899670b9ec280f0a8b03d8f223e508e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0a1fbf13b10b5c06ee65c508d46881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#acf0a1fbf13b10b5c06ee65c508d46881">startsWith</a> (const T *prefix)</td></tr>
<tr class="separator:acf0a1fbf13b10b5c06ee65c508d46881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea9bc7c2670c440cc5195d37595e93e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a5ea9bc7c2670c440cc5195d37595e93e">startsWith</a> (const std::vector&lt; T &gt; &amp;prefix)</td></tr>
<tr class="separator:a5ea9bc7c2670c440cc5195d37595e93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113702ffd592bad1aa559f8a7cb7c737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a113702ffd592bad1aa559f8a7cb7c737">startsWith</a> (const T *prefix) const </td></tr>
<tr class="separator:a113702ffd592bad1aa559f8a7cb7c737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08587b6f74482be1e92f606ba855f68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Trie.xhtml#a08587b6f74482be1e92f606ba855f68b">startsWith</a> (const std::vector&lt; T &gt; &amp;prefix) const </td></tr>
<tr class="separator:a08587b6f74482be1e92f606ba855f68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt;<br/>
class Mezzanine::Trie&lt; T, V, Cmp, Items &gt;</h3>

<p><a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> main class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type for each element in the key </td></tr>
    <tr><td class="paramname">V</td><td>Type of the value that the key will be representing </td></tr>
    <tr><td class="paramname">Cmp</td><td>Comparison functor </td></tr>
    <tr><td class="paramname">Items</td><td>The data structure that represents each node in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a>. Items can be Mezzanine::SetItems&lt;T, V, Cmp&gt; or Mezzanine::VectorItems&lt;T, V, Cmp, Max&gt;, Max is the integer representing number of elements in each <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> node.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="usage_sec"></a>
Usage of the Trie</h1>
<h2><a class="anchor" id="usage_declaration"></a>
Declarating the Trie</h2>
<p>A <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> with key as chars and value as std::string can be declared as given below </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;trie.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Mezzanine::Trie&lt;char, std::string&gt;</a> dictionary(<span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="usage_population"></a>
Populatiion and deletion from the Trie</h2>
<p><a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> can be populated by using the <a class="el" href="classMezzanine_1_1Trie.xhtml#a67580e4e58c4f7c792cfc9cb6c310adc">Trie::insert</a> method and element can be removed using <a class="el" href="classMezzanine_1_1Trie.xhtml#a75c1f0d6190a5f9d697c2bbe7d3b7f66">Trie::erase</a>. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;trie.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Mezzanine::Trie&lt;char, std::string&gt;</a> dictionary(<span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// adding key value pair to the Trie</span></div>
<div class="line">    <span class="keywordflow">if</span> (dictionary.insert(<span class="stringliteral">&quot;karma$&quot;</span>, <span class="stringliteral">&quot;Destiny or fate, following as effect from cause&quot;</span>).second) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;added karma&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// removing key from the Trie</span></div>
<div class="line">    <span class="keywordflow">if</span> (dictionary.erase(<span class="stringliteral">&quot;karma$&quot;</span>)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;removed karma&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="usage_retrieval"></a>
Retrieval of Value</h2>
<p>Value for a key can be retrieved using <a class="el" href="classMezzanine_1_1Trie.xhtml#a01f6a2995c275b9f6af235449eae0164">Trie::get</a> method and the existence of the key can be tested using <a class="el" href="classMezzanine_1_1Trie.xhtml#a3f9ae81ddaee9806e4a9570e6a668a65">Trie::hasKey</a> method. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;trie.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Mezzanine::Trie&lt;char, std::string&gt;</a> dictionary(<span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line"></div>
<div class="line">    dictionary.insert(<span class="stringliteral">&quot;karma$&quot;</span>, <span class="stringliteral">&quot;Destiny or fate, following as effect from cause&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (dictionary.hasKey(<span class="stringliteral">&quot;karma$&quot;</span>)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;key karma found&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    std::string * result = dictionary.get(<span class="stringliteral">&quot;karma$&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (result) {</div>
<div class="line">        std::cout &lt;&lt; result-&gt;c_str() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="usage_searching"></a>
Searching keys which have common prefix</h2>
<p>Keys which begins with a specific charactars can be retrieved using <a class="el" href="classMezzanine_1_1Trie.xhtml#acf0a1fbf13b10b5c06ee65c508d46881">Trie::startsWith</a> method </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;trie.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Mezzanine::Trie&lt;char, std::string&gt;</a> dictionary(<span class="charliteral">&#39;\0&#39;</span>);</div>
<div class="line"></div>
<div class="line">    dictionary.insert(<span class="stringliteral">&quot;karma&quot;</span>, <span class="stringliteral">&quot;Destiny or fate, following as effect from cause&quot;</span>);</div>
<div class="line">    <a class="code" href="classMezzanine_1_1Node_1_1iterator.xhtml">Mezzanine::Trie&lt;char, std::string&gt;::iterator</a> iter = dictionary.startsWith(<span class="stringliteral">&quot;kar&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (; iter != dictionary.end(); ++iter) {</div>
<div class="line">        std::cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; iter-&gt;second-&gt;c_str() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="usage_array_of_node"></a>
Trie with each Node as an array</h2>
<p>Here each node of the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> is an array. The advantage is that the searching of a symbol in the array takes O(1) time (is constant time). The disadvantage is that the array will have empty elements so the space used will more than actually required.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;trie.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Here 256 is the size of array in each node</span></div>
<div class="line">    <a class="code" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Mezzanine::Trie&lt;char, std::string, std::less&lt;char&gt;</a>,</div>
<div class="line">              <a class="code" href="classMezzanine_1_1VectorItems.xhtml" title="Container representing each node in the Trie.">Mezzanine::VectorItems&lt;char, std::string, std::less&lt;char&gt;</a>, 256&gt; &gt; dictionary(<span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="usage_vector_item"></a>
Efficient use of Trie for alphabets</h2>
<p>Below example shows how to use <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> to operate on alphabets efficiently. Here <a class="el" href="classMezzanine_1_1VectorItems.xhtml" title="Container representing each node in the Trie.">VectorItems</a> is used to store alphabets with size of 28 (26 alphabets + space + end symbol).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;trie.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>TrieCaseInsensitiveCompare</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keywordtype">char</span> v1, <span class="keywordtype">char</span> v2) {</div>
<div class="line">        <span class="keywordtype">int</span> i1 = std::tolower(v1);</div>
<div class="line">        <span class="keywordtype">int</span> i2 = std::tolower(v2);</div>
<div class="line">        <span class="keywordflow">return</span> i1 &lt; i2;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// key to vector index converter</span></div>
<div class="line"><span class="comment">// case insensitive and includes alphabets, space and end symbol</span></div>
<div class="line"><span class="keyword">class </span>AlphaToIndex</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> operator()(<span class="keyword">const</span> <span class="keywordtype">char</span> &amp; c)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0;</div>
<div class="line">        <span class="keywordflow">if</span> (c == <span class="charliteral">&#39; &#39;</span>) {</div>
<div class="line">            index = 27;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c &gt;= <span class="charliteral">&#39;A&#39;</span> &amp;&amp; c &lt;= <span class="charliteral">&#39;Z&#39;</span>) {</div>
<div class="line">            index = c - <span class="charliteral">&#39;A&#39;</span> + 1;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; c &lt;= <span class="charliteral">&#39;z&#39;</span>) {</div>
<div class="line">            index = c - <span class="charliteral">&#39;a&#39;</span> + 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> index;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Mezzanine::Trie</a>&lt;char, std::string,</div>
<div class="line">              TrieCaseInsensitiveCompare,</div>
<div class="line">              <a class="code" href="classMezzanine_1_1VectorItems.xhtml" title="Container representing each node in the Trie.">Mezzanine::VectorItems&lt;char, std::string, TrieCaseInsensitiveCompare, 28, AlphaToIndex&gt;</a></div>
<div class="line">              &gt; dictionary(<span class="charliteral">&#39;\0&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// adding key value pair to the Trie</span></div>
<div class="line">    <span class="keywordflow">if</span> (dictionary.insert(<span class="stringliteral">&quot;karma&quot;</span>, <span class="stringliteral">&quot;Destiny or fate, following as effect from cause&quot;</span>).second) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;added karma&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// removing key from the Trie</span></div>
<div class="line">    <span class="keywordflow">if</span> (dictionary.erase(<span class="stringliteral">&quot;karma&quot;</span>)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;removed karma&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="usage_set_of_node"></a>
Trie with each Node as a set</h2>
<p>Here each node will be an ordered set. Here there will be no extra usage of space but search for a symbol in the node takes logarithmic time. <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> with this feature can also be used for caseinsensitive symbol handling. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;trie.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Mezzanine::Trie&lt;char, std::string, std::less&lt;char&gt;</a>,</div>
<div class="line">              <a class="code" href="classMezzanine_1_1SetItems.xhtml" title="Container representing each node in the Trie.">Mezzanine::SetItems&lt;char, std::string, std::less&lt;char&gt;</a> &gt; &gt; dictionary(<span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="usage_iterator"></a>
Using Trie::iterator</h2>
<p><a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> iterator can be used the same way as STL iterator. Key and value can be accessed from iterator using first and secod member. first is vector of key characters and second is a pointer to the value. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;trie.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Mezzanine::Trie&lt;char, std::string&gt;</a> dictionary(<span class="charliteral">&#39;\0&#39;</span>);</div>
<div class="line"></div>
<div class="line">    dictionary.insert(<span class="stringliteral">&quot;karma$&quot;</span>, <span class="stringliteral">&quot;Destiny or fate, following as effect from cause&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMezzanine_1_1Node_1_1iterator.xhtml">Mezzanine::Trie&lt;char, std::string&gt;::iterator</a> iter = dictionary.begin();</div>
<div class="line">    <a class="code" href="classMezzanine_1_1Node_1_1iterator.xhtml">Mezzanine::Trie&lt;char, std::string&gt;::iterator</a> iend = dictionary.end();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (; iter != iend; ++iter) {</div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; iter-&gt;first  &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; iter-&gt;second-&gt;c_str() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01287">1287</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad7376e936e82653cbab401ed7d687491"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::<a class="el" href="classMezzanine_1_1Trie.xhtml">Trie</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>endSymbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endSymbol</td><td>The symbol which marks the end of key input </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01297">1297</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4dd0c3d9f2dba87694ccc8d8bbc8d11e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator referring to the first element in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first element in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01502">1502</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="afc492cd9669d95794902f950e4fc4de9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an constant iterator referring to the first element in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="section return"><dt>Returns</dt><dd>An constant iterator to the first element in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01555">1555</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a262a7d3ac86df54b33e288a66f4b52a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All the elements in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> are dropped, leaving the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> with a size of 0. </p>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01448">1448</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4998ab08d9805d20d80db053bf697829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> is empty </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> size is 0, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01433">1433</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a18e820b5697ad8730d9dd55e99a717a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator referring to the past-the-end element in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element past the end of the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01510">1510</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a66193cb5ac0e09be52920001be7756f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an constant iterator referring to the past-the-end element in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="section return"><dt>Returns</dt><dd>An constant iterator to the element past the end of the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01563">1563</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="acdbcd1af4164693fd620555c54fa4e14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::endSymbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the end symbol </p>
<dl class="section return"><dt>Returns</dt><dd>end symbol </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01494">1494</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a75c1f0d6190a5f9d697c2bbe7d3b7f66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the entry with the given key from the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key which should be erased, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given key is erased from the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a>, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01326">1326</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4619367a402a232f481b1d641086c55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the entry with the given key from the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key which should be erased, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given key is erased from the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a>, false otherwise </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000048">Todo:</a></b></dt><dd>Currently this uses a hack that isn't safe for all types and circumstances. This should be changed to use "data()" function member new to C++11 when we make that dive. </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01335">1335</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab950dee1f5c6f8febdaac8680d67f7ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the entry with the given key from the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator pointing to a single element to be removed from the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given key is erased form the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a>, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01345">1345</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="acbd96c9934412acf143d02a04611402e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> for an element with 'key' as key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element with key 'key' if found, otherwise an iterator to <a class="el" href="classMezzanine_1_1Trie.xhtml#a18e820b5697ad8730d9dd55e99a717a6">Trie::end</a> </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01519">1519</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="af62d2af1cdba67c2548559dfbc3eb3d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> for an element with 'key' as key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element with key 'key' if found, otherwise an iterator to <a class="el" href="classMezzanine_1_1Trie.xhtml#a18e820b5697ad8730d9dd55e99a717a6">Trie::end</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000055">Todo:</a></b></dt><dd>Currently this uses a hack that isn't safe for all types and circumstances. This should be changed to use "data()" function member new to C++11 when we make that dive. </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01528">1528</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2cfc6490c6fb9c97e9eb2f9398a8f2b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> for an element with 'key' as key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the element with key 'key' if found, otherwise an const_iterator to <a class="el" href="classMezzanine_1_1Trie.xhtml#a18e820b5697ad8730d9dd55e99a717a6">Trie::end</a> </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01538">1538</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a33d22651cec97e81fbbb72afa11ada20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> for an element with 'key' as key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the element with key 'key' if found, otherwise an const_iterator to <a class="el" href="classMezzanine_1_1Trie.xhtml#a18e820b5697ad8730d9dd55e99a717a6">Trie::end</a> </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01547">1547</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a01f6a2995c275b9f6af235449eae0164"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const V* <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the value for the given key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to value for the given key, 0 on failure </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01354">1354</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a38579433efd18197dc1ecd561e7f980e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const V* <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the value for the given key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to value for the given key, 0 on failure </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000049">Todo:</a></b></dt><dd>Currently this uses a hack that isn't safe for all types and circumstances. This should be changed to use "data()" function member new to C++11 when we make that dive. </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01363">1363</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31de0baad77dd4b4e3dcf6ec5b6acf83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the value for the given key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value for the given key, 0 on failure </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01373">1373</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="aafcbfec88414be1df315332eca91f37e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the value for the given key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value for the given key, 0 on failure </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000050">Todo:</a></b></dt><dd>Currently this uses a hack that isn't safe for all types and circumstances. This should be changed to use "data()" function member new to C++11 when we make that dive. </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01382">1382</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3f9ae81ddaee9806e4a9570e6a668a65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::hasKey </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the given key is present in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key is present </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01415">1415</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8eac01bdeb5aeab9db1cf5b31a72c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::hasKey </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the given key is present in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key is present </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000052">Todo:</a></b></dt><dd>Currently this uses a hack that isn't safe for all types and circumstances. This should be changed to use "data()" function member new to C++11 when we make that dive. </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01424">1424</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a67580e4e58c4f7c792cfc9cb6c310adc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>, bool&gt; <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a key with value in to the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key which should be inserted, should be terminated by 'end' symbol </td></tr>
    <tr><td class="paramname">value</td><td>The value that is to be set with the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An std::pair with pair::first set to the iterator points to the element and pair::second to true is key is newly inserted, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01306">1306</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac026d0ba7f978e5c5255c31fd7dd5c2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a>, bool&gt; <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a key with value in to the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key which should be inserted, should be terminated by 'end' symbol </td></tr>
    <tr><td class="paramname">value</td><td>The value that is to be set with the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An std::pair with pair::first set to the iterator points to the element and pair::second to true is key is newly inserted, false otherwise </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000047">Todo:</a></b></dt><dd>Currently this uses a hack that isn't safe for all types and circumstances. This should be changed to use "data()" function member new to C++11 when we make that dive. </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01316">1316</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="aab4908e8278627fe1bd16d388ecfd86b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V&amp; <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the value for the given key, If key does not match the key of any element in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a>, the function inserts a new element with that key and returns a reference to its mapped value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to value for the given key </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01394">1394</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4404d2030747b2306e9c4d5ed8c2ee58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V&amp; <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the value for the given key, If key does not match the key of any element in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a>, the function inserts a new element with that key and returns a reference to its mapped value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be searched for, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to value for the given key </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000051">Todo:</a></b></dt><dd>Currently this uses a hack that isn't safe for all types and circumstances. This should be changed to use "data()" function member new to C++11 when we make that dive. </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01405">1405</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a899670b9ec280f0a8b03d8f223e508e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </p>
<dl class="section return"><dt>Returns</dt><dd>Number of key value pair in the <a class="el" href="classMezzanine_1_1Trie.xhtml" title="Trie main class.">Trie</a> </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01441">1441</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="acf0a1fbf13b10b5c06ee65c508d46881"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::startsWith </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves iterator to the elements with common prefix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Part of the key which should be searched, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the elements with prefix specified in 'prefix' </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01457">1457</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5ea9bc7c2670c440cc5195d37595e93e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1iterator.xhtml">iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves iterator to the elements with common prefix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Part of the key which should be searched, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the elements with prefix specified in 'prefix' </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000053">Todo:</a></b></dt><dd>Currently this uses a hack that isn't safe for all types and circumstances. This should be changed to use "data()" function member new to C++11 when we make that dive. </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01466">1466</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a113702ffd592bad1aa559f8a7cb7c737"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::startsWith </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves const_iterator to the elements with common prefix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Part of the key which should be searched, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the elements with prefix specified in 'prefix' </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01476">1476</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<a class="anchor" id="a08587b6f74482be1e92f606ba855f68b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename V, typename Cmp = std::less&lt;T&gt;, typename Items = SetItems&lt;T, V, Cmp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1Node_1_1const__iterator.xhtml">const_iterator</a> <a class="el" href="classMezzanine_1_1Trie.xhtml">Mezzanine::Trie</a>&lt; T, V, Cmp, Items &gt;::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves const_iterator to the elements with common prefix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Part of the key which should be searched, should be terminated by 'end' symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the elements with prefix specified in 'prefix' </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000054">Todo:</a></b></dt><dd>Currently this uses a hack that isn't safe for all types and circumstances. This should be changed to use "data()" function member new to C++11 when we make that dive. </dd></dl>

<p>Definition at line <a class="el" href="trie_8h_source.xhtml#l01485">1485</a> of file <a class="el" href="trie_8h_source.xhtml">trie.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/Code/Mezzanine/Mezzanine/src/<a class="el" href="trie_8h_source.xhtml">trie.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 13 2013 23:29:56 for MezzanineEngine by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1</small></address>
</body>
</html>
